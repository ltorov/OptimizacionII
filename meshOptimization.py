# -*- coding: utf-8 -*-
"""MeshOptimization.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1MUZnjKnV4W3b_lDfASdwoDwAD_XjH3l_
"""

import numpy as np
import sympy as sym
import matplotlib.pyplot as plt
import plotly.figure_factory as ff
from mpl_toolkits.mplot3d import Axes3D
import math
from sympy.abc import x,y
from sympy.utilities.lambdify import lambdify
from scipy import integrate

def generateNodes(X,Y,n,m):
  Nodes = []
  for y in np.linspace(0, Y, num = m):
    for x in np.linspace(0, X, num = n):
      Nodes.append([x,y])
  Nodes = np.array(Nodes)
  plt.plot(Nodes[:,0],Nodes[:,1],'o')
  plt.xlabel("x")
  plt.ylabel("y")
  plt.show()
  return Nodes

X = 3
Y = X
n = 20
m = n
Nodes = generateNodes(X,Y,n,m)

def mesh2d(Nodes,n,m):
  tri = triangulate(m,n)
  plt.triplot(Nodes[:,0], Nodes[:,1], tri)
  plt.plot(Nodes[:,0], Nodes[:,1], 'o')
  
  plt.xlabel("x")
  plt.ylabel("y")
  plt.show()
  return tri

def triangulate(m,n):
  tri = []
  cont = 0 
  for i in range(m):
    for j in range(n):
      if cont%n != n-1:
        tri.append([cont,cont+1,cont+n])
        tri.append([cont+1,cont+n, cont+n+1])
      cont = cont+1
      if cont == (m*n - n-1):
        return tri
  return tri

def areas2d(tri):
  Areas = []
  for i in range(len(tri)):
    a,b,c = tri[0], tri[1], tri[2]
    a,b,c = Nodes[a,:],Nodes[b,:],Nodes[c,:]
    A = (abs(a[0]*(a[1]-b[1])+b[0]*(c[1]-a[1])+c[0]*(a[1]-b[1])))/2
    Areas.append(A[0])
    return Areas

tri = mesh2d(Nodes,n,m)

def areas3d(Nodes,tri,Z):
  Areas = []
  for triangle in tri:
    an,bn,cn = triangle[0], triangle[1], triangle[2]
    a,b,c = Nodes[an,:],Nodes[bn,:],Nodes[cn,:]
    ab = [(b[0]-a[0]),(b[1]-a[1]),(Z[bn]-Z[an])]
    ac = [(c[0]-a[0]),(c[1]-a[1]),(Z[cn]-Z[an])]
    abxac = [(ab[1]*ac[2]- ab[2]*ac[1] ),(ab[0]*ac[2]-ab[2]*ac[0]),(ab[0]*ac[1]-ab[1]*ac[0])]
    A = (1/2)*math.sqrt((abxac[0]**2)+(abxac[1]**2)+(abxac[2]**2))
    Areas.append(A)
  return Areas

def functionMesh(Nodes, tri, n,m):
  X = Nodes[:,0]
  Y = Nodes[:,1]
  Z = (X*Y*(X**2 - Y**2))/(X**2 + Y**2 + 1)
  fig  = ff.create_trisurf(X, Y, Z,colormap="Portland",simplices=tri,title="Mesh")
  fig.show()
  return Z
Z = functionMesh(Nodes, tri, n,m)
Areas = areas3d(Nodes,tri,Z)
var = np.var(Areas)
var

pip install optimesh

import optimesh

cells = tri
points = np.ones([400,3])



points[:,0],points[:,1], points[:,2] = Nodes[:,0], Nodes[:,1],Z

Areas = areas3d(points[:,[0,1]],cells,points[:,2])
var0 = np.var(Areas)

points, cells = optimesh.optimize_points_cells(
    points,
    cells,
    "odt bfgs",
    1.0e-10,
    1000)

Z = functionMesh(points, cells, n,m)


Areas = areas3d(points[:,[0,1]],cells,points[:,2])

var1 = np.var(Areas)


plt.triplot(points[:,0], points[:,1], tri)
plt.plot(points[:,0], points[:,1], 'o')
plt.xlabel("x")
plt.ylabel("y")
plt.show()

var0,var1

def surfaceArea(s,ya,yb,xa,xb,typet):
  slope = (yb-ya)/(xb-xa)
  b = ya-(slope*xa)
  if typet == 0:
    S = integrate.dblquad(s, ya, yb, lambda x: xa, lambda x: slope * x +b)
  else:
    S = integrate.dblquad(s, ya, yb, lambda x: slope * x +b, lambda x: xb)
  return abs(S[0])

def surfaceAreaTriangles(f, tri):
  Areas = []
  cont = 0
  for t in tri:
    an,bn,cn = t[0], t[1],t[2]
    ya,yb,xa,xb = Nodes[an,1],Nodes[cn,1],Nodes[an,0],Nodes[bn,0]
    u = sym.diff(f, x)
    v = sym.diff(f, y)
    s = (1 + u**2 + v**2)**(1/2)
    s = lambdify((x,y),s)
    Areas.append(surfaceArea(s,ya,yb,xa,xb,cont%2))
    cont = cont+1
  return (Areas)

def error(Areas, surfaceAreas):
  dif = []
  for i in range(len(Areas)):
    dif.append(abs(Areas[i]-surfaceAreas[i]))
  return dif

x, y = sym.symbols("x y")
f = (x*y*(x**2 - y**2))/(x**2 + y**2 + 1)


surfaceAreas = surfaceAreaTriangles(f, tri)
errores = error(Areas, surfaceAreas)

s = 0
for i in surfaceAreas:
  s = s+ i


print(math.sqrt(s))

u = sym.diff(f, x)
v = sym.diff(f, y)
s = (1 + u**2 + v**2)**(1/2)
s = lambdify((x,y),s)
S = integrate.dblquad(s, 0, 3, lambda x: 0, lambda x: 3)

print(S)
print(Areas)
print(surfaceAreas)

def main(X=3,Y=3,n=10,m=10):
  Nodes = generateNodes(X,Y,n,m)
  tri = mesh2d(Nodes,n,m)
  Z = functionMesh(Nodes, tri, n,m)
  Areas = areas3d(Nodes,tri,Z)
  x, y = sym.symbols("x y")
  f = (x*y*(x**2 - y**2))/(x**2 + y**2 + 1)
  surfaceAreas = surfaceAreaTriangles(f, tri)
  var = np.var(Areas)
  s = 0
  for i in surfaceAreas:
    s = s+ i
  print(s)
  u = sym.diff(f, x)
  v = sym.diff(f, y)
  s = (1 + u**2 + v**2)**(1/2)
  s = lambdify((x,y),s)
  S = integrate.dblquad(s, 0, 3, lambda x: 0, lambda x: 3)
  print(S)
  print(Areas)
  print(surfaceAreas)
  return var


print("The variance of the triangles in the mesh is " + str(main(n=20,m=20))+".")