# -*- coding: utf-8 -*-
"""Métodos multiobjetivo Optimizacion 2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1x3dbNQYDgtF1jtxtQ1Q-n1avVeCG8rBz

Método TOPSIS
"""

import numpy as np
import pandas as pd
from numpy import linalg as LA
import math

def metodoTOPSIS(matrizDecision, criterios, alternativas, criteriominmax, pesos, tiponorma):
  mD = pd.DataFrame(matrizDecision,  index = alternativas, columns=criterios)
  col = len(mD.columns)
  rows = len(mD.index)

  Pesos = (pd.DataFrame(pesos, index = criterios, columns = ["Pesos"])).T
  print("Método TOPSIS")
  print("")
  print("Paso 1: Matriz de Decisión")
  print("")
  print(mD)
  print("")
  print(Pesos)
  print("")

  norma = np.zeros(col)
  if tiponorma == 2:
    for i in range(col):
      norma[i]= LA.norm(matrizDecision[:,i])
  elif tiponorma == 1:
    for i in range(col):
      norma[i]= LA.norm(matrizDecision[:,i],1)
  elif tiponorma == "inf":
    for i in range(col):
      norma[i]= LA.norm(matrizDecision[:,i],np.inf)
  for i in range(col):
    mD[criterios[i]] = mD[criterios[i]]/norma[i]

  norma = (pd.DataFrame(norma, index = criterios, columns = ["Norma"])).T

  print("Paso 2: Matriz de Decisión Normalizada")
  print("")
  print(mD)
  print("")
  print(norma)
  print("")

  for i in range(col):
    mD[criterios[i]] = mD[criterios[i]]*pesos[i]

  print("Paso 3: Matriz de Decisión Normalizada Ponderada")
  print("")
  print(mD)
  print("")

  minimos = mD.min(axis = 0)
  maximos = mD.max(axis = 0)
  ideal = []
  antiideal = []
  for i in range(col):
    if criteriominmax[i] == 0:
      ideal.append(minimos[i])
      antiideal.append(maximos[i])
    else:
      ideal.append(maximos[i])
      antiideal.append(minimos[i])
  alt = ["Alternativa ideal", "Alternativa anti-ideal"]
  idealantiideal = pd.DataFrame([ideal,antiideal], index= alt, columns=criterios)

  print("Paso 4: Alternativas ideal y anti-ideal")
  print("")
  print(idealantiideal)
  print("")

  medidasi = []
  a = []
  disti =  0
  dista =  0
  medidasa = []

  if tiponorma == 2:
    for i in range(rows):
      disti, dista = 0,0
      for j in range(col):
        b = mD[criterios[j]]
        c = idealantiideal[criterios[j]]
        disti = disti + ((c[alt[0]]-b[alternativas[i]])**2)
        dista = dista + ((c[alt[1]]-b[alternativas[i]])**2)
      disti = math.sqrt(disti)
      dista = math.sqrt(dista)
      medidasi.append(disti)
      medidasa.append(dista)
  elif tiponorma == 1:
    for i in range(rows):
      disti, dista = 0,0
      for j in range(col):
        b = mD[criterios[j]]
        c = idealantiideal[criterios[j]]
        disti = disti + (abs(c[alt[0]]-b[alternativas[i]]))
        dista = dista + (abs(c[alt[1]]-b[alternativas[i]]))
      medidasi.append(disti)
      medidasa.append(dista)
  elif tiponorma == "inf":
    for i in range(rows):
      disti, dista = [],[]
      for j in range(col):
        b = mD[criterios[j]]
        c = idealantiideal[criterios[j]]
        disti.append(abs(c[alt[0]]- b[alternativas[i]]))
        dista.append(abs(c[alt[1]]- b[alternativas[i]]))
      di = max(disti)
      da = max(dista)
      medidasi.append(di)
      medidasa.append(da)

  medidas = pd.DataFrame([medidasi, medidasa], index= alt, columns=alternativas).T

  print("Paso 5: Medidas de distancia")
  print("")
  print(medidas)
  print("")

  proxi = []
  for i in range(rows):
    disti, dista = 0,0
    b = medidas[alt[0]]
    c = medidas[alt[1]]
    d = b[alternativas[i]]
    e = c[alternativas[i]]
    proxi.append((e)/(e+d))

  proximidadRelativa = ["Proximidad Relativa"]  
  proximidadesRelativas = pd.DataFrame(proxi, index=alternativas , columns=proximidadRelativa)

  print("Paso 6: Proximidad relativa a la alternativa ideal")
  print("")
  print(proximidadesRelativas)
  print("")

  proximidadesRelativas.sort_values(by=proximidadRelativa, inplace=True, ascending=False)

  print("Paso 7: Ranking")
  print("")
  print(proximidadesRelativas)
  print("")

"""
Input:
matrizDecision = Una matriz con los valores de los criterios según las alternativas en formato numpy matrix
criterios = una lista de los nombres de los criterios
alternativas = una lista de los nombres de las alternativas
criteriominmax = una lista del tamano de criterios con 0 para minimización y 1 para maximización
pesos = una lista con los pesos
tiponorma = el tipo de norma que se desea usar, acepta norma l1, norma l2 y norma l+inf

Output:
Imprime paso a paso del método TOPSIS
"""

"""Ejercicio de clase"""

matrizDecision = np.matrix([[185, 6.5, 12.85], [290,7.5,13.695],[310,7.6,12.87]
                  ,[245,6.5,11.385], [325, 7.55, 11.235],[235,6.85,12.525]])
criterios = ['Co (min)', 'Ca (min)', 'Vu (max)']
criteriominmax = [0,0,1]
alternativas = ['Proveedor 1','Proveedor 2','Proveedor 3','Proveedor 4','Proveedor 5','Proveedor 6']
pesos = [0.3, 0.4, 0.3]
tiponorma = 1
metodoTOPSIS(matrizDecision, criterios, alternativas, criteriominmax, pesos, tiponorma)

"""Ejercicio del parcial
Punto 2 a

"""

matrizDecision = np.matrix([[1,5], [4,2],[3,3]])
criterios = ['C1', 'C2']
alternativas = ['A1', 'A2', 'A3']
criteriominmax = [1,1]
pesos = [0.5, 0.5]
tiponorma = 'inf'
metodoTOPSIS(matrizDecision, criterios, alternativas, criteriominmax, pesos, tiponorma)

"""Método ELECTRE"""

import numpy as np
import pandas as pd
from numpy import linalg as LA
import math

pd.set_option('display.max_rows', None)
pd.set_option('display.max_columns', None)
pd.set_option('display.width', 1000)
pd.set_option('display.colheader_justify', 'center')
pd.set_option('display.precision', 5)


def metodoELECTRE(matrizDecision, criterios, alternativas, criteriominmax, pesos, UC, UD):
  mD = pd.DataFrame(matrizDecision,  index = alternativas, columns=criterios)
  col = len(mD.columns)
  rows = len(mD.index)

  Pesos = (pd.DataFrame(pesos, index = criterios, columns = ["Pesos"])).T
  print("Método ELECTRE")
  print("")
  print("Paso 1: Matriz de Decisión")
  print("")
  print(mD)
  print("")
  print(Pesos)
  print("")

  minimos = mD.min(axis = 0)
  maximos = mD.max(axis = 0)
  rango = maximos - minimos

  a = ["Mínimo", "Máximo", "Rango"]
  normalizar = pd.concat([minimos, maximos, rango], axis=1).T
  print("Paso 2: Matriz de Decisión Normalizada")
  print("")
  print(normalizar)
  print("")
  rij = 0
  a = []
  mDN = []
  for i in range(rows):
    a= []
    for j in range(col):
      rij = 0
      ind = criteriominmax[j]
      b = mD[criterios[j]]
      c = normalizar[criterios[j]]
      min = c [0]
      max = c [1]
      rango = c[2]
      if ind == 0:
        rij = (max - b[alternativas[i]])/(max-min)
      else: 
        rij = (b[alternativas[i]] - min)/(max-min)
      a.append(rij)
    mDN.append(a)
  
  mD = pd.DataFrame(mDN,  index = alternativas, columns=criterios)
  mDN = mD.copy()


  print(mDN)
  print("")

  mDNP = mDN.copy()
  for i in range(col):
    mDNP[criterios[i]] = mD[criterios[i]]*pesos[i]

  print("Paso 3: Matriz de Decisión Normalizada Ponderada")
  print("")
  print(mDNP)
  print("")

  C = np.zeros((rows, rows))
  C = pd.DataFrame(C,  index = alternativas, columns=alternativas)
  D = C

  mc = np.zeros((rows, rows))
  r = 0
  for i in range(rows):
    for j in range(rows):
      if i == j:
        mc [i][j] = -1
      else:
        for k in range(col):
          a = mD[criterios[k]]
          Ci = a[alternativas[i]]
          Cj = a[alternativas[j]]
          if Ci>Cj:
            r = r + pesos[k]
          if Ci== Cj:
            if i<j:
              r = r + pesos[k]
        mc [i][j] = r
        r = 0

  C = pd.DataFrame(mc,  index = alternativas, columns=alternativas)

  print("Paso 4: Matriz de Concordancia")
  print("")
  print(C)
  print("")

  md = np.zeros((rows, rows))
  r = 0
  diferencias = []
  dif = 0
  mayor = []
  for i in range(rows):
    for j in range(rows):
      if i == j:
        md [i][j] = -1
      else:
        Di,Dj,dif,mayor,a = 0,0,0,0,0
        diferencias = []
        alti = mDNP.loc[ alternativas[i] , : ]
        altj = mDNP.loc[ alternativas[j] , : ]
        diferencias = abs(alti-altj)
        mayor = diferencias.max(axis = 0)
        for c in range(col):
          a = mDNP[criterios[c]]
          Di = a[alternativas[i]]
          Dj = a[alternativas[j]]
          if Di<Dj:
            if (Di-Dj)< dif:
              dif = Di-Dj
        md [i][j] = abs(dif/mayor)

          
  D = pd.DataFrame(md,  index = alternativas, columns=alternativas)
      
  print("Paso 5: Matriz de Discordancia")
  print("")
  print(D)
  print("")

  for i in range(rows):
    for j in range(rows):
      if i == j:
        mc [j][i] = -1
      else:
        a = C[alternativas[i]]
        b = a[alternativas[j]]
        if b>UC:
          mc[j][i] = 1
        else:
          mc[j][i] = 0

  C = pd.DataFrame(mc,  index = alternativas, columns=alternativas)

  print("Paso 6: Matriz de Dominancia Concordante")
  print("")
  print(C)
  print("")

  for i in range(rows):
    for j in range(rows):
      if i == j:
        md [j][i] = -1
      else:
        a = D[alternativas[i]]
        b = a[alternativas[j]]
        if b<UD:
          md[j][i] = 1
        else:
          md[j][i] = 0

  D = pd.DataFrame(md,  index = alternativas, columns=alternativas)

  print("Paso 7: Matriz de Dominancia Discordante")
  print("")
  print(D)
  print("")

  mda = np.zeros((rows, rows))
  for i in range(rows):
    for j in range(rows):
      if i == j:
        mda [j][i] = -1
      else:
        a = C[alternativas[i]]
        b = a[alternativas[j]]
        c = D[alternativas[i]]
        d = c[alternativas[j]]
        mda[j][i] = b*d
  DA = pd.DataFrame(mda,  index = alternativas, columns=alternativas)


  print("Paso 8: Matriz de Dominancia Agregada")
  print("")
  print(DA)
  print("")

  print("Paso 9: Grafo ELECTRE")
  print("")

  print("")


"""
Input:
matrizDecision = Una matriz con los valores de los criterios según las alternativas en formato numpy matrix
criterios = una lista de los nombres de los criterios
alternativas = una lista de los nombres de las alternativas
criteriominmax = una lista del tamano de criterios con 0 para minimización y 1 para maximización
pesos = una lista con los pesos
UC = Umbral de concordancia, es dado por el decisor
UD = Umbral de discordancia, es dado por el decisor

Output:
Imprime paso a paso del método ELECTRE
"""

"""Ejercicio de clase"""

matrizDecision = np.matrix([[185, 6.5, 12.85], [290,7.5,13.695],[310,7.6,12.87]
                  ,[245,6.5,11.385], [325, 7.55, 11.235],[235,6.85,12.525]])
criterios = ['Co (min)', 'Ca (min)', 'Vu (max)']
criteriominmax = [0,0,1]
alternativas = ['Proveedor 1','Proveedor 2','Proveedor 3','Proveedor 4','Proveedor 5','Proveedor 6']
pesos = [0.3, 0.4, 0.3]
UC = 0.5
UD = 0.5869

metodoELECTRE(matrizDecision, criterios, alternativas, criteriominmax, pesos, UC, UD)

"""Ejercicio del parcial
Punto 2b
"""

matrizDecision = np.matrix([[1,5], [4,2],[3,3]])
criterios = ['C1', 'C2']
alternativas = ['A1', 'A2', 'A3']
criteriominmax = [1,1]
pesos = [0.5, 0.5]
UC = 0.5
UD = 0.5869

metodoELECTRE(matrizDecision, criterios, alternativas, criteriominmax, pesos, UC, UD)

"""Método Promethee"""

import numpy as np
import pandas as pd
from numpy import linalg as LA
import math

def metodoPromethee(matrizDecision, criterios, alternativas, criteriominmax, pesos):
  mD = pd.DataFrame(matrizDecision,  index = alternativas, columns=criterios)
  col = len(mD.columns)
  rows = len(mD.index)

  Pesos = (pd.DataFrame(pesos, index = criterios, columns = ["Pesos"])).T

  print("Método Promethee")
  print("")
  print("Paso 1: Matriz de Decisión")
  print("")
  print(mD)
  print("")
  print(Pesos)
  print("")

  print("Paso 2: Matrices de Diferencias")
  print("")

  D=[]

  mc = np.zeros((rows, rows))
  for c in range(col):

    for i in range(rows):
      for j in range(rows):
        if i == j:
          mc [i][j] = 0
        else:
          a = mD[criterios[c]]
          b = a[alternativas[i]]
          d = a[alternativas[j]]
          mc[j][i] = b-d
    C = pd.DataFrame(mc,  index = alternativas, columns=alternativas)
    print(criterios[c])
    print(C)
    print("")

    D.append(C.copy())

  print("Paso 3: Matrices de Preferencias")
  print("")

  C = np.zeros((rows, rows))
  P =[]

  minimos = mD.min(axis = 0)
  maximos = mD.max(axis = 0)
  rango = maximos - minimos

  r = 0
  s = 0
  mc = np.zeros((rows, rows))
  for c in range(col):
    r = rango[criterios[c]]
    a = D[c]
    for i in range(rows):
      for j in range(rows):
        b = a[alternativas[i]]
        x = b[alternativas[j]]

        if x <= s:
          mc[i][j] = 0
        elif (x>s) and (x<= r):
          mc[i][j] = (x-s)/r
        else: 
          mc[i][j] = 1
    C = pd.DataFrame(mc,  index = alternativas, columns=alternativas)
    print(criterios[c])
    print(C)
    print("")
    P.append(C.copy())

  print("Paso 4: Matriz de Indices de Preferencias Agregados")
  print("")

  indices = np.zeros((rows, rows))
  suma = 0

  for i in range(rows):
    for j in range(rows):
      if i == j:
        indices[i][j] = 0
      else:
        for c in range(col):
          peso = pesos[c]
          C = P[c]
          a = C[alternativas[j]]
          b = float(a[alternativas[i]])
          suma = suma + b*peso
        indices[i][j] = suma
        suma = 0
    I = pd.DataFrame(indices,  index = alternativas, columns=alternativas)
  sumai= 0
  sumaj = 0
  Sumai = []
  Sumaj = []
  for i in range(rows):
    for j in range(rows):
      sumai = sumai+ indices[i][j]
    Sumai.append(sumai)
    sumai = 0

  for j in range(rows):
    for i in range(rows):
      sumaj = sumaj+ indices[i][j]
    Sumaj.append(sumaj)
    sumaj = 0
  Is = I.copy()
  Is['Suma'] =  Sumai

  Suma = pd.DataFrame(Sumaj,  index = alternativas , columns= ["Suma"]).T

  Is = pd.concat([Is, Suma], axis = 0)

  print(Is)
  print("")

  print("Paso 5: Flujos de Sobrecalificación")
  print("")
  flujos = np.zeros((rows, 2))

  for i in range(rows):
    a = Sumai[i]
    b = Sumaj[i]
    c = rows -1
    flujos[i][0] = a/c
    flujos[i][1] = b/c

  findices = ['Flujo positivo', 'Flujo negativo']
  Flujos = pd.DataFrame(flujos,  index = alternativas, columns=[findices])
  flujos = np.array(flujos)
  print(Flujos)
  print("")

  Flujopositivo = pd.DataFrame(flujos[:,0],  index = alternativas, columns=[findices[0]])
  Flujopositivo.sort_values(by=[findices[0]], inplace=True, ascending=False)

  print("Paso 6: Ranking según el Flujo de Sobrecalificación positivo")
  print("(mayor es mejor)")
  print("")
  print(Flujopositivo)
  print("")

  Flujonegativo = pd.DataFrame(flujos[:,1],  index = alternativas, columns=[findices[1]])
  Flujonegativo.sort_values(by=[findices[1]], inplace=True, ascending=False)

  print("Paso 7: Ranking según el Flujo de Sobrecalificación negativo")
  print("(menor es mejor)")
  print("")
  print(Flujonegativo)
  print("")

  flujoNeto = np.zeros((rows,1))

  for i in range(rows):
    a = flujos[i][0]
    b = flujos[i][1]
    flujoNeto[i] = a-b

  f = ["Flujo positivo", "Flujo negativo"]
  Flujos["Flujo Neto"] = flujoNeto
  Flujoneto = pd.DataFrame(flujoNeto,  index = alternativas, columns=["Flujo Neto"])
  Flujoneto.sort_values(by=["Flujo Neto"], inplace=True, ascending=False)

  print("Paso 8 (Promethee II): Flujo neto de superación")
  print("")
  print(Flujos)
  print("")

  print("Paso 9 (Promethee II): Ranking")
  print("(mayor es mejor)")
  print("")
  print(Flujoneto)
  print("")

"""
Input:
matrizDecision = Una matriz con los valores de los criterios según las alternativas en formato numpy matrix
criterios = una lista de los nombres de los criterios
alternativas = una lista de los nombres de las alternativas
criteriominmax = una lista del tamano de criterios con 0 para minimización y 1 para maximización
pesos = una lista con los pesos

Output:
Imprime paso a paso del método Promethee
"""

"""Punto 3 del parcial"""

matrizDecision = np.matrix([[6,9,1], [8,8,6],[8,8,7]
                  ,[7,9,7]])
criterios = ['Tamaño', 'Cámara', 'Precio']
criteriominmax = [1,1,1]
alternativas = ['Apple I. 66','Sony E. Z3','Motorola M. X','Samsung G. S5']
pesos = [0.35, 0.35, 0.3]
tiponorma = 2
#metodoTOPSIS(matrizDecision, criterios, alternativas, criteriominmax, pesos, tiponorma)

metodoPromethee(matrizDecision, criterios, alternativas, criteriominmax, pesos)

"""Ejemplo
https://www.youtube.com/watch?v=Iibmeqk3pFk

"""

matrizDecision = np.matrix([[80,90,60,5.4,8,5],[65,58,20,9.7,1,1],[83,60,40,7.2,4,7],[40,80,100,7.5,7,10],[52,72,60,2,3,8],[94,96,70,3.6,5,6]])
criterios =  ['C1','C2','C3','C4','C5','C6']
criteriominmax = [0,1,0,0,0,1]
alternativas = ['A1','A2','A3','A4','A5','A6']
p = 1/6
pesos = [p,p,p,p,p,p]

metodoPromethee(matrizDecision, criterios, alternativas, criteriominmax, pesos)

"""Método simplex multiobjetivo

"""

import numpy as np
import pandas as pd
from scipy.optimize import linprog

c = np.array([[6,4,5], [0,0,1]])
b = np.array([12,12,12])
a = np.array([[1,1,2],[1,2,1],[2,1,1]])
minmax = [1,1]
menormayor = ["<=", "<=", "<="]
x = ['x1','x2','x3']


def simplexMultiobjetivo(a,b,c, minmax,menormayor,x):
  print("Paso 0: Problema de programación lineal multiobjetivo")
  print("Paso 1: Introducción de las variables de holgura")
  print("Paso 2: Tabla Simplex base")
  print("")
  tablaSimplex = np.zeros((len(a),(len(a)+len(x))))
  s=[]
  col = x.copy()
  for i in range(1,len(a)+1):
    s.append( "s"+str(len(x)+i))
    col.append(s[i-1])
  base = s


  X = pd.DataFrame(a, index=base, columns = x)
  S = pd.DataFrame(np.identity(len(a)), index = base, columns = s)
  X = X.join(S)


  C=[]
  g = []
  for i in range(len(c)):
    g = []
    for j in range(len(c[i])):
      g.append(c[i][j])
    for j in range(len(a)):
      g.append(0)
    C.append(g)


  C=pd.DataFrame(C,columns = col, index = ['C1-Z1', 'C2-Z2'])

  TablaSimplex = pd.concat([C,X])



  B = pd.DataFrame(b, index = base, columns = ['z'])
  TablaSimplex = TablaSimplex.join(B)

  TablaSimplex.fillna(value=0, inplace=True)

  print(TablaSimplex)
  index = TablaSimplex.index

  print("Paso 3: Reformulación de la tabla Simplex")
  print("")

  g = []
  g = TablaSimplex.iloc[0]+ TablaSimplex.iloc[1]

  G = pd.DataFrame(g, columns=['cj-zj']).T
  TablaSimplex = pd.concat([G,TablaSimplex])
  index = np.array(TablaSimplex.index)
  columns = TablaSimplex.columns
  print(TablaSimplex)
  print("")

  print("Paso 4: Operaciones elementales")
  boo = True
  while(boo):
    g = []
    g = TablaSimplex.iloc[0]
    max = 0
    maxi = 0
    for i in range(len(g-1)):
      if g[columns[i]] >= max:
        max = g[columns[i]]
        maxi = i
    
    min = []
    g = []
    g = TablaSimplex[columns[maxi]]

    z = TablaSimplex['z']
    j = len(g)-1
    min = 10000000
    minj= 0 
    valor = 0
    for i in range (len(s)):
      div = z[j]/g[j]
      if div<min:
        min = div
        minj = j
        valor = g[j]
      j = j-1

    print("Sale "+ index[j+1] + " y entra " + columns[maxi])

    sale = TablaSimplex.iloc[j+1]
    pivote = sale/valor



    TablaSimplex.iloc[j+1] =pivote

    for i in range(len(index)):
      if i != j+1:
        sale = TablaSimplex.iloc[i]

        entra = sale - sale[maxi] * pivote

        TablaSimplex.iloc[i] = entra
    index[j+1]=columns[maxi]
    TablaSimplex.set_index(index, inplace= True)
    print(TablaSimplex)
    boo = False



  print("Paso 5:")


"""
Input:
Z =
R = 
b = 
minmax = una lista del tamano de criterios con 0 para minimización y 1 para maximización
menormayor = 

Output:
Imprime paso a paso del método simplex multiobjetivo
"""

"Lo intenté programar pero todavía no he llegado a la solución"
simplexMultiobjetivo(a,b,c,minmax,menormayor,x)

"""https://repositorio.unprg.edu.pe/bitstream/handle/20.500.12893/4877/BC-TES-3688%20MASABEL%20CARRANZA-PAZ%20ACOSTA.pdf?sequence=1&isAllowed=y

https://www.lamsade.dauphine.fr/~projet_cost/ALGORITHMIC_DECISION_THEORY/pdf/Ehrgott/HanLecture2_ME.pdf
"""